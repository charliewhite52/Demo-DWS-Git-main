from optimizers.BaseOptimizer import BaseOptimizerimport pulpfrom models import ScheduleResponse, ScheduleRequestclass GradualOptimizer(BaseOptimizer):        def __init__(self):        self.problem = None            def optimize(self, request: ScheduleRequest, phase=1) -> ScheduleResponse:        """Optimize with gradual constraint phases"""                self.problem = pulp.LpProblem(f"{phase}", pulp.LpMinimize)                # Create decision variables        assignments = {}        for employee in request.employees:            for shift in request.shifts:                var_name = f"assign_{employee.id}_{shift.id}"                assignments[(employee.id, shift.id)] = pulp.LpVariable(var_name, cat='Binary')                self._apply_phase1_constraints(assignments, request)        if phase >= 2:            self._apply_phase2_constraints(assignments, request)         if phase >= 3:            self._apply_phase3_constraints(assignments, request)        if phase >= 4:            self._apply_phase4_constraints(assignments, request)                    self._set_objective_function(assignments, request)        self.problem.solve(pulp.PULP_CBC_CMD(msg=1))        status = pulp.LpStatus[self.problem.status]                if status == "Infeasible":            from optimizers.FallbackOptimizer import FallbackOptimizer            fallback = FallbackOptimizer()            fallback_response, understaffed = fallback.optimize_relaxed(request)            return fallback_response        else:                        response = self._build_response(request, assignments, phase)            return response            def _apply_phase1_constraints(self, assignments, request):        """Phase 1: Basic hours and coverage"""                for employee in request.employees:            weekly_hours = pulp.lpSum([                assignments[(employee.id, s.id)] * self._get_shift_hours(s.shift_type)                for s in request.shifts            ])            self.problem += weekly_hours <= employee.max_hours_per_week, f"max_hours_{employee.id}"                self.min_hours_slack = {}        for employee in request.employees:            weekly_hours = pulp.lpSum([                assignments[(employee.id, s.id)] * self._get_shift_hours(s.shift_type)                for s in request.shifts            ])            slack_var = pulp.LpVariable(f"min_hours_slack_{employee.id}", lowBound=0, cat='Continuous')            self.min_hours_slack[employee.id] = slack_var            self.problem += weekly_hours + slack_var >= 8, f"min_hours_{employee.id}"                for shift in request.shifts:            shift_coverage = pulp.lpSum([assignments[(e.id, shift.id)] for e in request.employees])            self.problem += shift_coverage >= shift.min_employees, f"min_staff_{shift.id}"            self.problem += shift_coverage <= shift.max_employees, f"max_staff_{shift.id}"        def _apply_phase2_constraints(self, assignments, request):        """Phase 2: Department matching"""                department_bonus_terms = []        for employee in request.employees:            for shift in request.shifts:                if employee.department == shift.department:                    department_bonus_terms.append(assignments[(employee.id, shift.id)] * 500)                self.department_bonus_terms = department_bonus_terms        def _apply_phase3_constraints(self, assignments, request):        """Phase 3: No-overlap constraints"""                for employee in request.employees:            shifts_by_date = {}            for shift in request.shifts:                key = (employee.id, shift.id)                if key in assignments:                    if shift.date not in shifts_by_date:                        shifts_by_date[shift.date] = []                    shifts_by_date[shift.date].append(assignments[key])                        for date, shift_vars in shifts_by_date.items():                if len(shift_vars) > 1:                    self.problem += pulp.lpSum(shift_vars) <= 1, f"one_shift_per_day_{employee.id}_{date}"        def _apply_phase4_constraints(self, assignments, request):        """Phase 4: Qualification constraints"""                to_remove = []        for employee in request.employees:            for shift in request.shifts:                if not self._is_qualified(employee, shift):                    key = (employee.id, shift.id)                    if key in assignments:                        # Fix variable to 0 for unqualified pairs                        self.problem += assignments[key] == 0, f"unqualified_{employee.id}_{shift.id}"            def _set_objective_function(self, assignments, request):        """DEBUG VERSION: Verify constraints are applied"""            constraint_details = []            for employee in request.employees:            shifts_by_date = {}            for shift in request.shifts:                key = (employee.id, shift.id)                if key in assignments:                    if shift.date not in shifts_by_date:                        shifts_by_date[shift.date] = []                    shifts_by_date[shift.date].append((shift, assignments[key]))                    for date, shift_info in shifts_by_date.items():                if len(shift_info) > 1:                    shift_vars = [s[1] for s in shift_info]                    shift_types = [s[0].shift_type.value for s in shift_info]                                    constraint_name = f"no_overlap_{employee.id}_{date}"                    self.problem += pulp.lpSum(shift_vars) <= 1, constraint_name                                    constraint_details.append({                        'employee': employee.name,                        'date': date,                        'shifts': shift_types,                        'constraint_name': constraint_name                    })            coverage_slack = {}        coverage_penalty = 0                for shift in request.shifts:            assigned_vars = [                assignments[(e.id, shift.id)]                 for e in request.employees                 if (e.id, shift.id) in assignments            ]            if assigned_vars:                understaffing = shift.min_employees - pulp.lpSum(assigned_vars)                coverage_penalty += understaffing * 1000            utilization_penalty = 0        for employee in request.employees:            total_assignments = pulp.lpSum([                assignments[(employee.id, s.id)]                for s in request.shifts                if (employee.id, s.id) in assignments            ])            utilization_penalty += (1 - total_assignments) * 500            self.problem += coverage_penalty + utilization_penalty            return constraint_details                        def _build_response(self, request, assignments, phase):        """Build proper response object"""                if self.problem.status == pulp.LpStatusInfeasible:            return self._build_infeasible_response(request)                result_assignments = {}        total_cost = 0        assigned_shifts_count = 0        understaffed_shifts = []                employee_assignments = {emp.id: [] for emp in request.employees}        employee_hours = {emp.id: 0 for emp in request.employees}        employee_daily_shifts = {emp.id: {} for emp in request.employees}                department_distribution = {}        skill_utilization = {}        senior_lead_count = 0        total_assignments_for_ratio = 0                for shift in request.shifts:            result_assignments[shift.id] = []            assigned_count = 0                        for employee in request.employees:                key = (employee.id, shift.id)                if key in assignments:                    var = assignments[key]                    if var.varValue == 1:                        result_assignments[shift.id].append(employee.id)                        employee_assignments[employee.id].append(shift.id)                        hours = self._get_shift_hours(shift.shift_type)                        employee_hours[employee.id] += hours                        total_cost += employee.cost_per_hour * hours                        assigned_shifts_count += 1                        assigned_count += 1                                                dept = employee.department                        department_distribution[dept] = department_distribution.get(dept, 0) + 1                        # Skill utilization                        skill_level = employee.skill_level if hasattr(employee, 'skill_level') else 'regular'                        skill_utilization[skill_level] = skill_utilization.get(skill_level, 0) + 1                        # Senior/Lead ratio                        if hasattr(employee, 'skill_level') and employee.skill_level in ['senior', 'lead']:                            senior_lead_count += 1                        total_assignments_for_ratio += 1                        # Track daily assignments                        if shift.date not in employee_daily_shifts[employee.id]:                            employee_daily_shifts[employee.id][shift.date] = []                        employee_daily_shifts[employee.id][shift.date].append(shift)                        if assigned_count < shift.min_employees:                understaffed_shifts.append({                    "shift_id": shift.id,                    "date": shift.date,                    "department": shift.department,                    "required": shift.min_employees,                    "assigned": assigned_count,                    "shift_type": shift.shift_type.value                })                overlap_violations = 0        for employee in request.employees:            for date, shifts_on_date in employee_daily_shifts[employee.id].items():                if len(shifts_on_date) > 1:                    overlap_violations += 1                if overlap_violations == 0:            print("No overlap violations detected")                # Employee utilization        idle_employees = 0        underutilized_employees = 0        fully_utilized_employees = 0        overtime_employees = 0                for employee in request.employees:            assigned_shifts = employee_assignments[employee.id]            hours_worked = employee_hours[employee.id]                        if len(assigned_shifts) == 0:                status = "IDLE"                idle_employees += 1            elif hours_worked < 8:                status = "UNDERUTILIZED"                underutilized_employees += 1            else:                status = "BUSY"                coverage_rate = len([s for s in request.shifts if len(result_assignments[s.id]) >= s.min_employees]) / len(request.shifts) * 100        senior_lead_ratio = (senior_lead_count / total_assignments_for_ratio * 100) if total_assignments_for_ratio > 0 else 0        high_traffic_risks = []                        for shift in request.shifts:            if (shift.priority >= 8 or                 shift.department in ['operations', 'traffic'] or                (hasattr(shift, 'expected_traffic') and getattr(shift, 'expected_traffic', 0) > 5000000)):                assigned_count = len(result_assignments.get(shift.id, []))                if assigned_count < shift.min_employees:                    high_traffic_risks.append(shift.id)            understaffed_risk = len(understaffed_shifts) * 15        idle_risk = idle_employees * 8        overlap_risk = overlap_violations * 25        overtime_risk = overtime_employees * 20        high_traffic_risk = len(high_traffic_risks) * 30            total_risk_score = min(understaffed_risk + idle_risk + overlap_risk + overtime_risk + high_traffic_risk, 100)            # Generate recommendations        recommendations = []        if understaffed_shifts:            recommendations.append(f"{len(understaffed_shifts)} shifts are understaffed")        if high_traffic_risks:            recommendations.append(f"{len(high_traffic_risks)} high-traffic shifts need attention")        if idle_employees > 0:            recommendations.append(f"{idle_employees} employees are idle - consider reassigning")        if underutilized_employees > 0:            recommendations.append(f"{underutilized_employees} employees are underutilized")        if overlap_violations > 0:            recommendations.append(f"{overlap_violations} overlap violations detected")        if overtime_employees > 0:            recommendations.append(f"{overtime_employees} employees are over capacity")            if not recommendations:            recommendations.append("Schedule looks good! All constraints satisfied")        elif coverage_rate > 90:            recommendations.append("Good overall coverage achieved")        elif coverage_rate < 70:            recommendations.append("Consider adding temporary staff or adjusting shift requirements")                        metrics = {            "total_shifts_scheduled": assigned_shifts_count,            "total_labor_cost": round(total_cost, 2),            "coverage_rate": round(coverage_rate, 1),            "assigned_shifts_count": assigned_shifts_count,            "understaffed_shifts_count": len(understaffed_shifts),            "idle_employees_count": idle_employees,            "underutilized_employees_count": underutilized_employees,            "fully_utilized_employees_count": fully_utilized_employees,            "overtime_employees_count": overtime_employees,            "overlap_violations": overlap_violations,            "optimization_phase": phase,            "senior_lead_ratio": round(senior_lead_ratio, 1),            "department_distribution": department_distribution,            "skill_utilization": skill_utilization,            "total_employees": len(request.employees),            "utilized_employees": len(request.employees) - idle_employees,            "average_hours_per_employee": round(sum(employee_hours.values()) / len(request.employees), 1) if request.employees else 0,            "utilization_rate": round(((len(request.employees) - idle_employees) / len(request.employees)) * 100, 1) if request.employees else 0,            "solution_type": "optimal" if self.problem.status == pulp.LpStatusOptimal else "feasible",            "is_optimal": self.problem.status == pulp.LpStatusOptimal,            "is_partial": self.problem.status != pulp.LpStatusOptimal,            }                risk_assessment = {            "understaffed_shifts": understaffed_shifts,            "high_traffic_risks": high_traffic_risks,            "risk_score": total_risk_score,            "risk_breakdown": {                "understaffed_risk": understaffed_risk,                "idle_risk": idle_risk,                "overlap_risk": overlap_risk,                "overtime_risk": overtime_risk,                "high_traffic_risk": high_traffic_risk                },            "recommendations": recommendations,            "critical_issues": {                "understaffed_critical": len([s for s in understaffed_shifts if s.get('priority', 0) >= 8]),                "high_traffic_understaffed": len(high_traffic_risks),                "severe_overlaps": overlap_violations                }            }                return ScheduleResponse(            assignments=result_assignments,            metrics=metrics,            total_cost=total_cost,            coverage_score=coverage_rate,            risk_assessment=risk_assessment        )        def _build_error_response(self, request, error_msg):        """Simple error response"""            # Create empty assignments        assignments = {s.id: [] for s in request.shifts}            metrics = {            "total_shifts_scheduled": 0,            "total_labor_cost": 0,            "coverage_rate": 0,            "assigned_shifts_count": 0,            "understaffed_shifts_count": len(request.shifts),            "idle_employees_count": len(request.employees),            "optimization_phase": "error",            "solution_type": "error"            }            risk_assessment = {            "understaffed_shifts": [{"shift_id": s.id, "required": s.min_employees, "assigned": 0} for s in request.shifts],            "risk_score": 100,            "recommendations": [f"Error: {error_msg}"]            }            return ScheduleResponse(            assignments=assignments,            metrics=metrics,            total_cost=0,            coverage_score=0,            risk_assessment=risk_assessment            )    def _build_infeasible_response(self, request):        """Simple infeasible response"""        return self._build_error_response(request, "No feasible solution found")    