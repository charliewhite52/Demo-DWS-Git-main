import pulp from optimizers.BaseOptimizer import BaseOptimizerfrom optimizers.GradualOptimizer import GradualOptimizerfrom models import ScheduleResponseclass FallbackOptimizer(BaseOptimizer):        def _solve_with_relaxed_constraints(self, request, phase):        """Try solving with relaxed constraints when original is infeasible"""            # Create a new problem with relaxed constraints        relaxed_problem = pulp.LpProblem("Relaxed", pulp.LpMinimize)            assignments = {}        for employee in request.employees:            for shift in request.shifts:                var_name = f"assign_{employee.id}_{shift.id}"                assignments[(employee.id, shift.id)] = pulp.LpVariable(var_name, cat='Binary')            # 1. HARD: No overlaps (this must always be satisfied)        overlap_constraints = 0        for employee in request.employees:            shifts_by_date = {}            for shift in request.shifts:                key = (employee.id, shift.id)                if key in assignments:                    if shift.date not in shifts_by_date:                        shifts_by_date[shift.date] = []                    shifts_by_date[shift.date].append(assignments[key])                    for date, shift_vars in shifts_by_date.items():                if len(shift_vars) > 1:                    relaxed_problem += pulp.lpSum(shift_vars) <= 1, f"no_overlap_{employee.id}_{date}"                    overlap_constraints += 1            # 2. REWARD: Positive incentive for making assignments        assignment_reward = 0        total_possible_assignments = 0                for employee in request.employees:            for shift in request.shifts:                if (employee.id, shift.id) in assignments:                    assignment_reward -= assignments[(employee.id, shift.id)] * 10                    total_possible_assignments += 1            # 3. Max hours (relaxed with heavy penalty)        max_hours_penalty = 0        for employee in request.employees:            weekly_hours = pulp.lpSum([                assignments[(employee.id, s.id)] * self._get_shift_hours(s.shift_type)                for s in request.shifts if (employee.id, s.id) in assignments            ])            excess_hours = weekly_hours - employee.max_hours_per_week            excess_penalty = pulp.LpVariable(f"excess_hours_{employee.id}", lowBound=0)            relaxed_problem += excess_penalty >= excess_hours, f"excess_def_{employee.id}"            max_hours_penalty += excess_penalty * 1000            # 4. Coverage (relaxed with medium penalty)        coverage_penalty = 0        for shift in request.shifts:            assigned_vars = [                assignments[(e.id, shift.id)]                 for e in request.employees                 if (e.id, shift.id) in assignments            ]            if assigned_vars:                total_assigned = pulp.lpSum(assigned_vars)                understaffing = pulp.LpVariable(f"understaff_{shift.id}", lowBound=0)                relaxed_problem += understaffing >= (shift.min_employees - total_assigned), f"understaff_def_{shift.id}"                coverage_penalty += understaffing * 100                                if shift.min_employees > 0:                    assignment_reward -= (total_assigned / shift.min_employees) * 5            # Set objective: balance assignments with constraint violations        relaxed_problem += assignment_reward + coverage_penalty + max_hours_penalty            # Solve relaxed problem with longer time limit        relaxed_problem.solve(pulp.PULP_CBC_CMD(msg=1, timeLimit=120))        relaxed_status = pulp.LpStatus[relaxed_problem.status]        if relaxed_status == "Infeasible":            print("Even relaxed constraints are infeasible - returning best effort solution")            return self._build_best_effort_response(request)        else:            print("Found solution with relaxed constraints")        # Extract solution        solved_assignments = {}        total_assignments = 0                for (emp_id, shift_id), var in assignments.items():            if pulp.value(var) == 1:                if shift_id not in solved_assignments:                    solved_assignments[shift_id] = []                solved_assignments[shift_id].append(emp_id)                total_assignments += 1        print(f"   Found {total_assignments} total assignments after relaxation.")        return self._build_comprehensive_response(request, solved_assignments, phase, "relaxed")    def _build_comprehensive_response(self, request, assignments, phase, solution_type):        """Build comprehensive response with analytics and risk assessment for fallback solutions"""                total_cost = 0        coverage_score = 0        total_shifts = len(request.shifts)        employee_hours = {emp.id: 0 for emp in request.employees}        employee_assignments = {emp.id: [] for emp in request.employees}        department_distribution = {}        skill_utilization = {}        senior_lead_count = 0        total_assignments_for_ratio = 0        understaffed_shifts = []        overlap_violations = 0        employee_daily_shifts = {emp.id: {} for emp in request.employees}        for shift in request.shifts:            assigned_emps = assignments.get(shift.id, [])            shift_hours = self._get_shift_hours(shift.shift_type)            assigned_count = len(assigned_emps)                        for emp_id in assigned_emps:                employee = next((e for e in request.employees if e.id == emp_id), None)                if employee:                    total_cost += employee.cost_per_hour * shift_hours                    employee_hours[emp_id] += shift_hours                    employee_assignments[emp_id].append(shift.id)                                        dept = employee.department                    department_distribution[dept] = department_distribution.get(dept, 0) + 1                                        skill_level = employee.skill_level if hasattr(employee, 'skill_level') else 'regular'                    skill_utilization[skill_level] = skill_utilization.get(skill_level, 0) + 1                                        if hasattr(employee, 'skill_level') and employee.skill_level in ['senior', 'lead']:                        senior_lead_count += 1                    total_assignments_for_ratio += 1                    if shift.date not in employee_daily_shifts[employee.id]:                        employee_daily_shifts[employee.id][shift.date] = []                    employee_daily_shifts[employee.id][shift.date].append(shift)                        if assigned_count < shift.min_employees:                understaffed_shifts.append({                    "shift_id": shift.id,                    "date": shift.date,                    "department": shift.department,                    "required": shift.min_employees,                    "assigned": assigned_count,                    "shift_type": shift.shift_type.value                })                        if assigned_count >= shift.min_employees:                coverage_score += 1        for employee in request.employees:            for date, shifts_on_date in employee_daily_shifts[employee.id].items():                if len(shifts_on_date) > 1:                    overlap_violations += 1        coverage_rate = (coverage_score / total_shifts * 100) if total_shifts else 0                idle_employees = sum(1 for emp in request.employees if employee_hours[emp.id] == 0)        underutilized_employees = sum(1 for emp in request.employees if 0 < employee_hours[emp.id] < 8)        fully_utilized_employees = sum(1 for emp in request.employees if 8 <= employee_hours[emp.id] <= emp.max_hours_per_week)        overtime_employees = sum(1 for emp in request.employees if employee_hours[emp.id] > emp.max_hours_per_week)                senior_lead_ratio = (senior_lead_count / total_assignments_for_ratio * 100) if total_assignments_for_ratio > 0 else 0                high_traffic_risks = []        for shift in request.shifts:            if (shift.priority >= 8 or                 shift.department in ['operations', 'traffic'] or                (hasattr(shift, 'expected_traffic') and getattr(shift, 'expected_traffic', 0) > 5000000)):                assigned_count = len(assignments.get(shift.id, []))                if assigned_count < shift.min_employees:                    high_traffic_risks.append(shift.id)                            understaffed_risk = len(understaffed_shifts) * 15        idle_risk = idle_employees * 8        overlap_risk = overlap_violations * 25        overtime_risk = overtime_employees * 20        high_traffic_risk = len(high_traffic_risks) * 30        total_risk_score = min(understaffed_risk + idle_risk + overlap_risk + overtime_risk + high_traffic_risk, 100)                recommendations = []        if solution_type == "relaxed":            recommendations.append("Using relaxed constraints solution (some constraints were violated)")        elif solution_type == "best_effort":            recommendations.append("Using best-effort assignment (optimization failed)")                    if understaffed_shifts:            recommendations.append(f"{len(understaffed_shifts)} shifts are understaffed")        if high_traffic_risks:            recommendations.append(f"{len(high_traffic_risks)} high-traffic shifts need attention")        if idle_employees > 0:            recommendations.append(f"{idle_employees} employees are idle")        if underutilized_employees > 0:            recommendations.append(f"{underutilized_employees} employees are underutilized")        if overlap_violations > 0:            recommendations.append(f"{overlap_violations} overlap violations detected")        if overtime_employees > 0:            recommendations.append(f"{overtime_employees} employees are over capacity")                    if solution_type == "best_effort":            recommendations.append("High-priority shifts were staffed first")            recommendations.append("Consider adding more employees or reducing shift requirements")        metrics = {            "total_shifts_scheduled": sum(len(emps) for emps in assignments.values()),            "total_labor_cost": round(total_cost, 2),            "coverage_rate": round(coverage_rate, 1),            "assigned_shifts_count": sum(len(emps) for emps in assignments.values()),            "understaffed_shifts_count": len(understaffed_shifts),            "idle_employees_count": idle_employees,            "underutilized_employees_count": underutilized_employees,            "fully_utilized_employees_count": fully_utilized_employees,            "overtime_employees_count": overtime_employees,            "overlap_violations": overlap_violations,            "optimization_phase": phase,            "senior_lead_ratio": round(senior_lead_ratio, 1),            "department_distribution": department_distribution,            "skill_utilization": skill_utilization,            "total_employees": len(request.employees),            "utilized_employees": len(request.employees) - idle_employees,            "average_hours_per_employee": round(sum(employee_hours.values()) / len(request.employees), 1) if request.employees else 0,            "utilization_rate": round(((len(request.employees) - idle_employees) / len(request.employees)) * 100, 1) if request.employees else 0,            "solution_type": solution_type,            "is_optimal": False,            "is_partial": True,        }                risk_assessment = {            "understaffed_shifts": understaffed_shifts,            "high_traffic_risks": high_traffic_risks,            "risk_score": total_risk_score,            "risk_breakdown": {                "understaffed_risk": understaffed_risk,                "idle_risk": idle_risk,                "overlap_risk": overlap_risk,                "overtime_risk": overtime_risk,                "high_traffic_risk": high_traffic_risk            },            "recommendations": recommendations,            "critical_issues": {                "understaffed_critical": len([s for s in understaffed_shifts if s.get('priority', 0) >= 8]),                "high_traffic_understaffed": len(high_traffic_risks),                "severe_overlaps": overlap_violations            },            "solution_type": solution_type        }                return ScheduleResponse(            assignments=assignments,            metrics=metrics,            total_cost=total_cost,            coverage_score=coverage_rate,            risk_assessment=risk_assessment        )    def _build_best_effort_response(self, request):        """Build a best-effort response when no solution can be found"""            assignments = {}        employee_hours = {emp.id: 0 for emp in request.employees}        employee_qualifications = {emp.id: set(emp.qualifications) for emp in request.employees}            sorted_shifts = sorted(request.shifts,                              key=lambda s: (s.priority, s.min_employees),                              reverse=True)            for shift in sorted_shifts:            shift_assignments = []            shift_hours = self._get_shift_hours(shift.shift_type)            shift_qualifications = set(shift.required_qualifications)                    available_employees = []            for employee in request.employees:                if not shift_qualifications.issubset(employee_qualifications[employee.id]):                    continue                if (employee_hours[employee.id] + shift_hours) <= employee.max_hours_per_week:                    available_employees.append(employee)                        available_employees.sort(key=lambda e: employee_hours[e.id])                    for employee in available_employees:                if len(shift_assignments) < shift.min_employees:                    shift_assignments.append(employee.id)                    employee_hours[employee.id] += shift_hours                else:                    break                    assignments[shift.id] = shift_assignments        return self._build_comprehensive_response(request, assignments, "best_effort", "best_effort")    def optimize_relaxed(self, request):        """        Entry point for fallback optimization.        Returns a tuple: (ScheduleResponse, list_of_understaffed_shifts)        """        try:            response = self._solve_with_relaxed_constraints(request, phase="relaxed")            understaffed = [                s.id for s in request.shifts                if len(response.assignments.get(s.id, [])) < s.min_employees            ]            print(f"Fallback optimization complete. Understaffed shifts: {len(understaffed)}")            return response, understaffed        except Exception:            import traceback            traceback.print_exc()            best_effort_response = self._build_best_effort_response(request)            understaffed = [s.id for s in request.shifts if len(best_effort_response.assignments.get(s.id, [])) < s.min_employees]                        return best_effort_response, understaffed